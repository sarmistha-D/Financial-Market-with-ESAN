# -*- coding: utf-8 -*-
"""Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yABOqzV46jiB3HOaVZD-1qvtyEnil5cD
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install tensorflow

# Commented out IPython magic to ensure Python compatibility.
# %pip install keras

import numpy as np
import tensorflow as tf
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense
import matplotlib.pyplot as plt

# Load the  price data
df = pd.read_csv('bitcoin.csv')
data5=pd.read_csv("sample.csv")

df.head()

df.tail()

df.shape

# Clean the data (if required)
df = df.dropna()  # Drop any rows with missing values

# Visualize the data
plt.figure(figsize=(315,35))
plt.plot(df['Start'], df['Close'])
plt.xlabel('Date')
plt.ylabel('Price')
plt.title('Bitcoin Price Data')
plt.show()

# Visualize the data
plt.figure(figsize=(15,5))
plt.plot(df['Start'], df['Close'])
plt.xlabel('Date')
plt.ylabel('Price')
plt.title('Bitcoin Price Data')
plt.show()

# Preprocess the data
data = df['Close'].values.reshape(-1, 1)
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Split the data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
test_size = len(scaled_data) - train_size
train_data = scaled_data[:train_size]
test_data = scaled_data[train_size:]

train_size,test_size

train_data

test_data

# Function to create sequences of data
def create_sequences(data, seq_length):
    X = []
    y = []
    for i in range(len(data) - seq_length):
        X.append(data[i:i+seq_length])
        y.append(data[i+seq_length])
    return np.array(X), np.array(y)

# Define the sequence length
sequence_length = 10

# Create the training sequences
X_train, y_train = create_sequences(train_data, sequence_length)

# Create the testing sequences
X_test, y_test = create_sequences(test_data, sequence_length)

print(X_train.shape), print(y_train.shape)

print(X_test.shape), print(y_test.shape)

# Build the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(sequence_length, 1)))
model.add(LSTM(50))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')

model.summary()

# Train the model
model.fit(X_train, y_train, epochs=50, batch_size=32)

# Evaluate the model
train_loss = model.evaluate(X_train, y_train, verbose=0)
test_loss = model.evaluate(X_test, y_test, verbose=0)
print(f'Training loss: {train_loss}')
print(f'Testing loss: {test_loss}')

# Make predictions
train_predictions = model.predict(X_train)
test_predictions = model.predict(X_test)

# Invert the scaling of the predictions
train_predictions = scaler.inverse_transform(train_predictions)
y_train = scaler.inverse_transform(y_train)
test_predictions = scaler.inverse_transform(test_predictions)
y_test = scaler.inverse_transform(y_test)

# Prepare dates for plotting
train_dates = df['Start'].values[sequence_length:train_size]
test_dates = df['Start'].values[train_size + sequence_length:]
pred_dates = data5['Start'].values[sequence_length:train_size]

### Calculate RMSE performance metrics
import math
from sklearn.metrics import mean_squared_error
math.sqrt(mean_squared_error(y_train,train_predictions))

### Test Data RMSE
math.sqrt(mean_squared_error(y_test,test_predictions))

len(test_data)

x_input=test_data[341:].reshape(1,-1)
x_input.shape

temp_input=list(x_input)
temp_input=temp_input[0].tolist()

temp_input

# Plot the results
plt.figure(figsize=(12, 6))
plt.plot(train_dates, y_train, label='Actual (Training)')
plt.plot(train_dates, train_predictions, label='Predicted (Training)')
plt.plot(test_dates, y_test, label='Actual (Testing)')
plt.plot(test_dates, test_predictions, label='Predicted (Testing)')

plt.xlabel('Date')
plt.ylabel('Bitcoin Price')
plt.title('Bitcoin Price Prediction')
plt.legend()
plt.show()

future_dates = pd.date_range('2023-05-05', periods=300)
future_dates = future_dates.values.reshape(-1, 1)
future_dates = np.float32(future_dates)
future_dates = tf.expand_dims(future_dates, axis=1)
pred = model.predict(future_dates)
print(pred)

import matplotlib.pyplot as plt
import tensorflow as tf



# Reshape the future_dates variable to a 2D array.
future_dates = tf.reshape(future_dates, (-1, 1))

# Plot the predicted Bitcoin price data.
plt.plot(future_dates, pred, label='Predicted Bitcoin Price')

# Add a title and labels to the axes.
plt.title('Bitcoin Price Prediction')
plt.xlabel('Date')
plt.ylabel('Bitcoin Price')

# Show the plot.
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %pip install dateutil

import matplotlib.pyplot as plt
import tensorflow as tf
import pandas as pd

# Convert the train_dates variable to a list.
train_dates_list = train_dates.tolist()

# Plot the actual Bitcoin price data.
plt.plot(pd.to_datetime(train_dates_list), y_train, label='Actual (Training)')
plt.plot(pd.to_datetime(train_dates_list), train_predictions, label='Predicted (Training)')
plt.plot(pd.to_datetime(test_dates), y_test, label='Actual (Testing)')
plt.plot(pd.to_datetime(test_dates), test_predictions, label='Predicted (Testing)')

# Convert the future_dates variable to a NumPy array.
future_dates_np = np.array(future_dates)

# Reshape the future_dates_np variable to a 1-d array.
future_dates_1d = future_dates_np.reshape(-1)

# Plot the predicted Bitcoin price data.
plt.plot(pd.to_datetime(future_dates_1d), pred, label='Predicted Bitcoin Price')

plt.xlabel('Date')
plt.ylabel('Bitcoin Price')
plt.title('Bitcoin Price Prediction')
plt.legend()
plt.show()