# -*- coding: utf-8 -*-
"""IEEE_Access.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BWn1bJQrVt2eUv-qf5fyUnCBXXC7Y6UG
"""

import torch
import torchvision
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import TensorDataset, DataLoader

from sklearn.metrics import hamming_loss
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.metrics import roc_auc_score
from sklearn.metrics import classification_report
from sklearn.metrics import  mean_absolute_error
from sklearn.model_selection import train_test_split, StratifiedKFold
from pathlib import Path
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
import statistics


import os
import pickle

import json
from sklearn import preprocessing


# import EarlyStopping
import os, sys

# sys.path.append('path_to_the_module/early-stopping-pytorch')
# from torchsample.callbacks import EarlyStopping


device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
# device='cpu'
print(device)

from transformers import BertTokenizer, TFBertModel, BertConfig, BertTokenizerFast
from sklearn.feature_extraction.text import CountVectorizer
vectorizer = CountVectorizer()
from finbert_embedding.embedding import FinbertEmbedding
from tqdm import tqdm
from sklearn.metrics import accuracy_score ,precision_score ,recall_score ,f1_score
import textdistance

class bert_span(nn.Module):
    def __init__(self ,):
        super(bert_span ,self).__init__()

        self.word_lstm = nn.LSTM(768 ,256 ,batch_first=True, bidirectional=True)

        self.q_w = nn.Linear(512 ,512)
        self.k_w = nn.Linear(512 ,512)
        self.v_w = nn.Linear(512 ,512)

        self.sent_lstm = nn.LSTM(512 ,256 ,batch_first = True, bidirectional = True)


        self.q_s = nn.Linear(512 ,512)
        self.k_s = nn.Linear(512 ,512)
        self.v_s = nn.Linear(512 ,512)

        dropout = 0.2

        self.softmax = nn.Softmax(dim=1)
        self.sigmoid = nn.Sigmoid()
        self.relu = nn.Tanh()
        self.dropout = nn.Dropout(dropout)

        # emotion

        self.emo_fc1 = nn.Linear(768 ,512)
        self.emo_fc2 = nn.Linear(512 ,256)
        self.emo_out = nn.Linear(256 ,7)
        self.emo_out_fin = nn.Linear(256 ,5)

        # sentiment

        self.sen_fc1 = nn.Linear(768 ,512)
        self.sen_fc2 = nn.Linear(512 ,256)
        self.sen_out = nn.Linear(256 ,7)
        self.sen_out_fin = nn.Linear(256 ,3)

        self.comp_fc1 = nn.Linear(768 ,512)
        self.comp_fc2 = nn.Linear(512 ,256)
        self.comp_fc3 = nn.Linear(256 ,128)
        self.comp_out = nn.Linear(128 ,2)

        self.span_fc1 = nn.Linear(768 ,512)
        self.span_fc2 = nn.Linear(256 ,128)

        # self.comp_fc = nn.Linear(128,64)
        self.span_out = nn.Linear(128 ,45 *2)

        self.sev_out = nn.Linear(128 ,5)


        self.alphas_m1 = nn.ParameterList([torch.nn.Parameter(torch.rand(1)) for i in range(1)])
        self.alphas_m2 = nn.ParameterList([torch.nn.Parameter(torch.rand(1)) for i in range(1)])



        # self.alphas_e = nn.ParameterList([torch.nn.Parameter(torch.rand(1)) for i in range(2)])
        self.alphas_s = nn.ParameterList([torch.nn.Parameter(torch.rand(1)) for i in range(2)])
        self.alphas_c = nn.ParameterList([torch.nn.Parameter(torch.rand(1)) for i in range(2)])
        self.alphas_sp = nn.ParameterList([torch.nn.Parameter(torch.rand(1)) for i in range(2)])

        # self.comp_out = nn.Linear(84,2)


    def forward(self ,x):

        batch = x.shape[0]

        word_lstm ,_ = self.word_lstm(x)

        q_w = self.q_w(word_lstm)
        k_w = self.k_w(word_lstm).permute(0 ,2 ,1)
        v_w = self.v_w(word_lstm)

        soft_att = self.softmax(torch.bmm(q_w ,k_w))

        self_w_att = torch.bmm(soft_att ,v_w)


        self_w_att = self_w_att.reshape(batch ,-1 ,5 ,512)

        self_w_att = torch.mean(self_w_att ,2)


        sent_lstm ,_ = self.sent_lstm(self.dropout(self_w_att))


        q_s = self.q_s(sent_lstm)
        k_s = self.k_s(sent_lstm).permute(0 ,2 ,1)
        v_s = self.v_s(sent_lstm)

        soft_att = self.softmax(torch.bmm(q_s ,k_s))

        self_s_att = torch.bmm(soft_att ,v_s)

        tweet_level = torch.mean(self_s_att ,1)


        final = self.dropout(tweet_level)



        emo_fc2 = self.relu(self.emo_fc2(final))
        emo_out = self.relu(self.emo_out(emo_fc2))
        sen_fc2 = self.relu(self.sen_fc2(final))
        sen_out = self.relu(self.sen_out(sen_fc2))

        comp_fc2 = self.relu(self.comp_fc2(final))

        central_b = sen_fc2 *self.alphas_s[0].expand_as(sen_fc2) + comp_fc2 *self.alphas_c[0].expand_as(comp_fc2)
        # central_b = comp_fc2

        comp_fc3 = self.relu(self.comp_fc3(central_b))

        emo_cat = torch.cat((emo_out ,torch.zeros(batch ,121).to(device)) ,1)
        sen_cat = torch.cat((sen_out ,torch.zeros(batch ,121).to(device)) ,1)

        central_s =  sen_cat *self.alphas_s[1].expand_as(sen_cat) + comp_fc3 *self.alphas_c[1].expand_as \
            (comp_fc3)   # + emo_cat*self.alphas_e[1].expand_as(emo_cat)

        span_out = self.relu(self.span_out(central_s))



        emo_out_fin = self.relu(self.emo_out_fin(emo_fc2))
        sen_out_fin = self.relu(self.emo_out_fin(sen_fc2))


        return  emo_out_fin ,sen_out_fin ,span_out





class EarlyStopping:
    """Early stops the training if validation loss doesn't improve after a given patience."""
    def __init__(self, patience=7, verbose=False, delta=0, path='checkpoint.pt', trace_func=print):
        """
        Args:
            patience (int): How long to wait after last time validation loss improved.
                            Default: 7
            verbose (bool): If True, prints a message for each validation loss improvement.
                            Default: False
            delta (float): Minimum change in the monitored quantity to qualify as an improvement.
                            Default: 0
            path (str): Path for the checkpoint to be saved to.
                            Default: 'checkpoint.pt'
            trace_func (function): trace print function.
                            Default: print
        """
        self.patience = patience
        self.verbose = verbose
        self.counter = 0
        self.best_score = None
        self.early_stop = False
        self.val_loss_min = np.Inf
        self.delta = delta
        self.path = path
        self.trace_func = trace_func
    def __call__(self, val_loss, model):

        score = -val_loss

        if self.best_score is None:
            self.best_score = score
            self.save_checkpoint(val_loss, model)
        elif score < self.best_score + self.delta:
            self.counter += 1
            self.trace_func(f'EarlyStopping counter: {self.counter} out of {self.patience}')
            if self.counter >= self.patience:
                self.early_stop = True
        else:
            self.best_score = score
            self.save_checkpoint(val_loss, model)
            self.counter = 0

    def save_checkpoint(self, val_loss, model):
        '''Saves model when validation loss decrease.'''
        if self.verbose:
            self.trace_func \
                (f'Validation loss decreased ({self.val_loss_min:.6f} --> {val_loss:.6f}).  Saving model ...')
        torch.save(model.state_dict(), self.path)
        self.val_loss_min = val_loss




output =open("train.json" ,"rb")

vector = json.load(output)
# Open the Crypto.xlsx as output and then load its value in vector
# output = pd.read_excel("Crypto.xlsx")
# vector = output.to_dict('records')
print(vector[0])

tweet = []
twt = []
senti = []
emoti = []
span_tweet = []
span_senti = []
span_emoti = []
sel = []


tokenizer = BertTokenizerFast.from_pretrained("SpanBERT/spanbert-base-cased")
finbert = FinbertEmbedding()

max = 0
m = []
tt = []
count = 0
countt = 0

# toekization
for e in tqdm(vector[:]):
  text = e['text']
  span = e['selected_text']
  # if len(span) <= 0: count += 1
  # print(f"Length of Span: {len(span)}")

  tokenized_text = tokenizer.encode_plus(text, return_offsets_mapping=True)
  tokenized_span = tokenizer.encode_plus(span, return_offsets_mapping=True)

  texts = tokenized_text['offset_mapping'][1:-1]
  spans = tokenized_span['offset_mapping'][1:-1]

  t = []
  s = []
  sp = []

  for each in texts:
    txt = text[each[0]:each[1]]
    s.append(txt)

  if len(span) > 0:
    for each in spans:
      txt = span[each[0]:each[1]]
      sp.append(txt)


  if len(s ) >45:
    ss = []
    for each in s:
      if len(each ) >1:
        ss.append(each)
      s = ss

    if len(span) > 0:
      sps = []
      for each in sp:
        if len(each ) >1:
          sps.append(each)
        sp = sps

  if len(s ) >45:
    ss = []
    for each in s:
      if len(each ) >2:
        ss.append(each)
      s = ss

    if len(span) > 0:
      sps = []
      for each in sp:
        if len(each ) >2:
          sps.append(each)
        sp = sps
    # print(s,sps,sp)

  # if len(s)>max:
  #   max = len(s)
  #   m.append(len(s))
  #   tt.append(s)
  # else:
  #   m.append(len(s))


  tweet.append(s)
  senti.append(e['sentiment'])
  emoti.append(e['emotion'])

  if len(span) > 0:
    countt += 1
    span_tweet.append(s)
    span_senti.append(e['sentiment'])
    span_emoti.append(e['emotion'])
    sel.append(sp)

tem_span = span_tweet

tweet1 = []
tweet2 = []
xxxx = 0

embed_dict = {}
for each in tqdm(tweet):
    t = []
    for word in each:
        xxxx += 1
        try:
            sentence_embedding = embed_dict[word]
        except:
            sentence_embedding = finbert.sentence_vector(word)
            embed_dict[word] = sentence_embedding
        t.append(sentence_embedding)
    t = torch.stack(t)
    tweet1.append(t)
    if each in span_tweet:
        tweet2.append(t)

tweet = tweet1
span_tweet = tweet2

# zero padding
pad = torch.zeros([768])
print(pad.shape)

for i in range(len(tweet)):
    if len(tweet[i]) < 45:
        for j in range(45 - len(tweet[i])):
            tweet[i] = torch.cat((tweet[i], pad.unsqueeze(0)), dim=0)
    else:
        tweet[i] = tweet[i][:45]

for i in range(len(span_tweet)):
    if len(span_tweet[i]) < 45:
        for j in range(45 - len(span_tweet[i])):
            span_tweet[i] = torch.cat((span_tweet[i], pad.unsqueeze(0)), dim=0)
    else:
        span_tweet[i] = span_tweet[i][:45]
#  span_tweet[i] = torch.stack(span_tweet[i])

# tweet = torch.load("tweet.pt")
# span_tweet = torch.load("span_tweet.pt")

# torch.save(tweet, "tweet.pt")
# torch.save(span_tweet, "span_tweet.pt")

span_classes = []
for n in tqdm(range(len(span_tweet))):
  label = [0 for x in range(45)]
  text_lst = tem_span[n]
  span_lst = sel[n]
  for each in range(len(text_lst)):
    if text_lst[each] != span_lst[0]:
      continue
    else:
      wheth = 'yes'
      for n in range(1 ,len(span_lst)):
        try:
          if span_lst[n] != text_lst[each +n]:
            wheth = 'no'
            break
          else:
            continue
        except:
          wheth = 'no'
          break
      if wheth == 'yes':
        for n in range(len(span_lst)):
          label[each +n] = 1
  span_classes.append(label)

# tweet = np.array(tweet)
senti = np.array(senti)
emoti = np.array(emoti)
span_senti = np.array(span_senti)
span_emoti = np.array(span_emoti)
span_classes = np.array(span_classes)

sen_dict = {}
emo_dict = {}
for each in vector:
  try:
    sen_dict[each['sentiment']] += 1
  except:
    sen_dict[each['sentiment']] = 1
  try:
    emo_dict[each['emotion']] += 1
  except:
    emo_dict[each['emotion']] = 1

print('Sentiment: \n' ,sen_dict)
print('\nEmotion: \n' ,emo_dict)



"""## Modes 1,2,3
### without span
"""


cnt = 0

skfolds = StratifiedKFold(n_splits=10, shuffle=True)
skfolds_val = StratifiedKFold(n_splits=10, shuffle=True)

model = bert_span().to(device)

lr = 0.00001

combined_params = list(model.parameters())

optimizer = torch.optim.Adam(combined_params, lr=lr, weight_decay=0)

criterion_bce = nn.BCELoss()  # Binary case
criterion_loss = nn.CrossEntropyLoss()

for train_index, test_index in skfolds.split(span_tweet, span_senti):
    # print("TRAIN:", train_index, "TEST:", test_index)

    tweet_train = [span_tweet[i] for i in train_index]
    senti_train = [span_senti[i] for i in train_index]
    emoti_train = [span_emoti[i] for i in train_index]
    sel_train = [span_classes[i] for i in train_index]


    tweet_test = [span_tweet[i] for i in test_index]
    emoti_test = [span_emoti[i] for i in test_index]
    senti_test = [span_senti[i] for i in test_index]
    sel_test = [span_classes[i] for i in test_index]

    x = tweet_train
    y = senti_train

    train = {"tweet": tweet_train, "emotion": emoti_train, "sentiment": senti_train, "span": sel_train}
    # val={"tweet":tweet_val,"emotion":emoti_val,"sentiment":senti_val}
    test = {"tweet": tweet_test, "emotion": emoti_test, "sentiment": senti_test, "span": sel_test}

    # for i in range(test["id"].shape[0]):
    #    print(test["id"][i])

    # Most imprtant Part the dar
    class Tweet(torch.utils.data.Dataset):
        def __init__(self, data):
            self.data = data

        def __len__(self):
            return len(self.data["sentiment"])


        def __getitem__(self, idx):
            if (torch.is_tensor(idx)):
                idx = idx.tolist()

            le = preprocessing.LabelEncoder()

            emotion = torch.tensor(le.fit_transform(self.data["emotion"])[idx]).long().to(device)
            sentiment = torch.tensor(le.fit_transform(self.data["sentiment"])[idx]).long().to(device)
            tweet = torch.tensor(self.data["tweet"][idx]).to(device)
            span = torch.tensor(self.data["span"][idx]).long().to(device)
            # selected_text=torch.tensor(self.data["selected_text"][idx]).long().to(device)

            sample = {

                "tweet": tweet,
                "emotion": emotion,
                "sentiment": sentiment,
                "span": span,
            }

            return sample


    tweet_train = Tweet(train)
    dataloader_train = DataLoader(tweet_train, batch_size=32, shuffle=False, num_workers=0)

    print("train_data loaded")

    tweet_test = Tweet(test)
    dataloader_test = DataLoader(tweet_test, batch_size=32, shuffle=False, num_workers=0)
    print("Test_data loaded")

    exp_path = "IIT NLP"

    import torch
    import torch.optim as optim
    import torch.nn as nn
    from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

def train_model(model, patience, n_epochs, mode):
    epochs = n_epochs
    mode = mode
    #     clip = 5

    train_acc_list = []
    val_acc_list = []
    train_loss_list = []
    val_loss_list = []

    model.train()

    for i in range(epochs):
        print('\nEpoch: ', i + 1)
        emo_total_loss_train = 0
        emo_total_train = 0
        emo_correct_train = 0
        sen_total_loss_train = 0
        sen_total_train = 0
        sen_correct_train = 0

        emo_pred = []
        emo_act = []
        sen_pred = []
        sen_act = []

        span_total_loss_train = 0
        span_total_train = 0
        span_correct_train = 0

        ROS = 0
        HD = 0
        JAC = 0

        for data in dataloader_train:

            tweet = data['tweet'].to(device)
            emotion_train = data['emotion'].to(device)
            sentiment_train = data['sentiment'].to(device)
            span_train = data['span'].to(device)

            emo_out, sen_out, span_out = model(tweet)
            span_out = span_out.view(-1, 45, 2)

            loss_ = [1, 2]
            loss_[0] = criterion_loss(emo_out.requires_grad_(), emotion_train.long())
            loss_[1] = criterion_loss(sen_out.requires_grad_(), sentiment_train.long())

            loss_lst = [0 for n in range(45)]
            for n in range(45):
                loss = criterion_loss(span_out[:, n, :].requires_grad_(), span_train[:, n].long())
                loss_lst[n] = loss

            if mode == 4: loss = sum(loss_lst)
            if mode == 5: loss = loss_[0] + sum(loss_lst)
            if mode == 6: loss = loss_[1] + sum(loss_lst)
            if mode == 7: loss = sum(loss_) + sum(loss_lst)
            loss = sum(loss_)
            optimizer.zero_grad()
            loss.backward()

            optimizer.step()

            # print('Loss:',loss)

            with torch.no_grad():
                _, predicted_train = torch.max(sen_out.data, 1)
                # predicted_train = (output.data>=0.5).float()
                sen_total_train += sentiment_train.size(0)
                # total_train += emotion_train.size(0)
                sen_correct_train += (predicted_train == sentiment_train).sum().item()

                sen_total_loss_train += loss_[1].item()

                sen_pred.append(predicted_train.tolist())
                sen_act.append(sentiment_train.tolist())

            with torch.no_grad():
                _, predicted_train = torch.max(emo_out.data, 1)
                # predicted_train = (output.data>=0.5).float()
                emo_total_train += emotion_train.size(0)
                # total_train += emotion_train.size(0)
                emo_correct_train += (predicted_train == emotion_train).sum().item()

                emo_total_loss_train += loss_[0].item()

                emo_pred.append(predicted_train)
                emo_act.append(emotion_train)

            with torch.no_grad():
                _, predicted_train = torch.max(span_out.data, 2)
                # predicted_train = (output.data>=0.5).float()
                span_total_train += span_train.size(0)
                # total_train += emotion_train.size(0)
                cor_tr = 0
                for n in range(len(span_train)):
                    a = predicted_train[n].tolist()
                    b = span_train[n].tolist()
                    if a == b:
                        cor_tr += 1
                    a = list(map(str, a))
                    b = list(map(str, b))
                    HD += textdistance.hamming.normalized_distance(''.join(a), ''.join(b))
                    JAC += textdistance.jaccard(a, b)
                    ROS += textdistance.ratcliff_obershelp(''.join(a), ''.join(b))
                span_correct_train += cor_tr

                span_total_loss_train += loss.item()

        train_acc = 100 * sen_correct_train / sen_total_train
        train_loss = sen_total_loss_train / sen_total_train

        print(f'SENTIMENT: Epoch {i + 1}: train_loss: {train_loss:.4f} train_acc: {train_acc:.4f}')
        sen_pred = sum(sen_pred, [])
        sen_act = sum(sen_act, [])
        # print(accuracy_score(sen_pred,sen_act))

        train_acc = 100 * emo_correct_train / emo_total_train
        train_loss = emo_total_loss_train / emo_total_train

        print(f'EMOTION: Epoch {i + 1}: train_loss: {train_loss:.4f} train_acc: {train_acc:.4f}')

        train_acc = 100 * span_correct_train / span_total_train
        train_loss = span_total_loss_train / span_total_train

        print(
            f'SPAN: Epoch {i + 1}: train_loss: {train_loss:.4f} train_acc: {train_acc:.4f} ')

    for i in range(1):
        emo_total_loss_test = 0
        emo_total_test = 0
        emo_correct_test = 0
        sen_total_loss_test = 0
        sen_total_test = 0
        sen_correct_test = 0

        emo_pred = []
        emo_act = []
        sen_pred = []
        sen_act = []

        span_total_loss_test = 0
        span_total_test = 0
        span_correct_test = 0

        ROS = 0
        JAC = 0
        HD = 0

        span_pred = []
        span_act = []

        for data in dataloader_test:

            tweet = data['tweet'].to(device)
            emotion_test = data['emotion'].to(device)
            sentiment_test = data['sentiment'].to(device)
            span_test = data['span'].to(device)

            emo_out, sen_out, span_out = model(tweet)
            loss_ = [1, 2]
            loss_[0] = criterion_loss(emo_out.requires_grad_(), emotion_test.long())
            loss_[1] = criterion_loss(sen_out.requires_grad_(), sentiment_test.long())

            span_out = span_out.view(-1, 45, 2)
            loss_lst = [0 for n in range(45)]
            for n in range(45):
                # print(span_out.shape)
                loss = criterion_loss(span_out[:, n, :].requires_grad_(), span_test[:, n].long())
                loss_lst[n] = loss

            if mode == 4: loss = sum(loss_lst)
            if mode == 5: loss = loss_[0] + sum(loss_lst)
            if mode == 6: loss = loss_[1] + sum(loss_lst)
            if mode == 7: loss = sum(loss_) + sum(loss_lst)
            # loss = sum(loss_) + sum(loss_lst)
            optimizer.zero_grad()
            # loss.backward()

            # optimizer.step()

            # print('Loss:',loss)

            with torch.no_grad():
                _, predicted_test = torch.max(sen_out.data, 1)
                sen_total_test += sentiment_test.size(0)
                # print("LOOK",predicted_test,sentiment_test)
                sen_correct_test += (predicted_test == sentiment_test).sum().item()
                sen_total_loss_test += loss_[1].item()

                sen_pred.append(predicted_test.tolist())
                sen_act.append(sentiment_test.tolist())

            with torch.no_grad():
                _, predicted_test = torch.max(emo_out.data, 1)
                emo_total_test += emotion_test.size(0)
                emo_correct_test += (predicted_test == emotion_test).sum().item()
                emo_total_loss_test += loss_[0].item()

                emo_pred.append(predicted_test.tolist())
                emo_act.append(emotion_test.tolist())

            with torch.no_grad():
                _, predicted_test = torch.max(span_out.data, 2)
                span_total_test += span_test.size(0)

                cor_tr = 0
                for n in range(len(span_test)):
                    a = predicted_test[n].tolist()
                    b = span_test[n].tolist()
                    if a == b:
                        cor_tr += 1
                    a = list(map(str, a))
                    b = list(map(str, b))
                    HD += textdistance.hamming.normalized_distance(''.join(a), ''.join(b))
                    JAC += textdistance.jaccard(a, b)
                    ROS += textdistance.ratcliff_obershelp(''.join(a), ''.join(b))
                span_correct_test += cor_tr
                span_total_loss_test += loss_lst[1].item()

        test_acc = 100 * sen_correct_test / sen_total_test
        test_loss = sen_total_loss_test / sen_total_test

        print('\n\nTEST')

        sen_pred = sum(sen_pred, [])
        sen_act = sum(sen_act, [])
        print(f'\nSENTIMENT: test_loss: {test_loss:.4f} test_acc: {test_acc:.4f}')
        print('Accuracy:', accuracy_score(sen_pred, sen_act))
        print('Precision:', precision_score(sen_pred, sen_act, average='macro'))
        print('Recall:', recall_score(sen_pred, sen_act, average='macro'))
        print('F1:', f1_score(sen_pred, sen_act, average='macro'))

        test_acc = 100 * emo_correct_test / emo_total_test
        test_loss = emo_total_loss_test / emo_total_test

        emo_pred = sum(emo_pred, [])
        emo_act = sum(emo_act, [])

        print(f'\nEMOTION: test_loss: {test_loss:.4f} test_acc: {test_acc:.4f}')
        print('Accuracy:', accuracy_score(emo_pred, emo_act))
        print('Precision:', precision_score(emo_pred, emo_act, average='macro'))
        print('Recall:', recall_score(emo_pred, emo_act, average='macro'))
        print('F1:', f1_score(emo_pred, emo_act, average='macro'))

        test_acc = 100 * span_correct_test / span_total_test
        test_loss = span_total_loss_test / span_total_test

        print(
            f'\nSPAN: test_loss: {test_loss:.4f} test_acc: {test_acc:.4f} \n      HD: {HD / span_total_train:.4f} JAC: {JAC / span_total_train:.4f} ROS: {ROS / span_total_train:.4f}\n')

    return model, train_acc_list, train_loss_list, i

n_epochs = 25
# early stopping patience; how long to wait after last time validation loss improved.
patience = 3
model, train_acc_list, train_loss_list, epoc_num = train_model(model, patience, n_epochs, 7)
# modes

# 4 : span alone
# 5 : emo + span
# 6 : sent + span
# 7 : all

# torch.save(model, exp_path +"/My_model.pt")
torch.save(model, "not_emotion.pt")